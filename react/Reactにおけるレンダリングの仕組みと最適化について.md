# React のレンダリングについて
* React は画面描画を JavaScript に一任しているのが肝
  * 従来の HTML/JavaScript では HTML 構造をブラウザが管理する DOM を操作していた → 『HTML要素を考慮する必要がある』
  * React は JavaScript であり、HTML要素を意識する必要が無い → その代わり JavaScript 用に DOM を管理できる `仮想DOM` という仕組みが採用されている
* 従来の DOM 操作であっても、React での DOM 操作であっても画面の再描画は発生するが、React による仮想 DOM での DOM 操作においては変更差分だけを再描画すれば良いので全体を再描画する手間が省かれている
  * レンダリングはコストの高い処理だが、これら処理の縮小化も JavaScript で画面を出力しているが故に実現可能となっている

---
* 以下の図を参考にする場合
  * 従来のDOM操作の場合、変更箇所だけでなく画面全体を再描画されていた
  * 仮想DOM操作であれば、変更箇所だけを感知して部分的に再描画する仕組み

![image](https://github.com/user-attachments/assets/77cdf9ae-4cd0-4885-8ad7-8920a994a4f8)



# Reactにおいて再レンダリングが起きる条件
```
1. "state" が更新されたコンポーネントは再レンダリング
  ・ `setXXX()` が処理された場合が該当
2. "props"が変更されたコンポーネントは再レンダリング
  ・ `<Component val={val}>` のように、コンポーネントに渡す値である "props" が変更された場合が該当
3. 再レンダリングされたコンポーネント配下の子要素は再レンダリング
```

* 【3.】以下の図において、"B"が再レンダリングされる場合は子要素の"C"も再レンダリングされるが、親要素の"A"は再レンダリングされない
![image](https://github.com/user-attachments/assets/32264825-270a-4cd7-b871-08998f429ecd)

# レンダリングの最適化１ (memo)
* 再レンダリングを制御する手段として **`React.memo`** を利用した **"メモ化"** がある
* メモ化では『propsの変更があるまでは親要素の再レンダリングが発生しても子要素は再レンダリングしない』ことが実現可能
  * 先述の【3.】を制限している感じ

# レンダリングの最適化２ (useCallback)
* 再レンダリングを制御する手段として **`useCallback`** を利用した **"関数のメモ化"** がある
* React.memo は単に『"props"値がレンダリング前後で更新されているか否か』で判別されて制御していたが、関数はレンダリングする度に書き換えられるため、レンダリング前後で全く別の関数として認識されてしまう
  * 結果として React.memo では制御が利かない
* これらの関数特有の問題を解決するために React.memo と似た関数のメモ化をするための "useCallback" が存在する


### 参考資料
* https://qiita.com/_lemoo_/items/5d295cba251b1e697939
